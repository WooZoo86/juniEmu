#!/usr/bin/python

'''
JuniEmu - emulator interface for ARM 32-bit. 

Using Unicorn framework for emulation, Capstone disassembly framework and 
Python's standard GUI (Graphical User Interface) package - Tkinter.

'''

import sys
import os
from collections import namedtuple
import collections
import threading
import time
import signal
import struct
from capstone.arm import *
import binascii
import pdb
import platform
import socket
import multiprocessing

from unicorn import *
from unicorn.arm_const import *
from unicorn.unicorn_const import *

if sys.version_info[0] < 3:
    from capstone import *

if sys.version_info[0] < 3:
    import Tkinter as tk
    import ttk as ttk
    from tkFileDialog import askopenfilename
    import tkFont
else:
    import tkinter as tk
    from tkinter import filedialog
    import tkinter.ttk as ttk
    import tkinter.messagebox as msg
    import tkinter.font as tkFont

BACKGROUND_COLOR = "black"
TEXT_COLOR = "#C0C0C0"
FONT_FAMILY = "Courier New"
FONT_SIZE = 9

print ("Unicorn version: {}.{}.{}".format(UC_VERSION_MAJOR, UC_VERSION_MINOR, UC_VERSION_EXTRA))

##################################################################################################
# CONFIG
##################################################################################################

IMAGEBASE = 0x00020000
ENTRYPOINT = 0x0

IS_THUMB_MODE = 0  # start mode

# leave empty if you want to choose file via open dialog
TEST_FILENAME = ""

##################################################################################################
# Registers start value
##################################################################################################

INITIALIZE_REG_R0 = 0
INITIALIZE_REG_R1 = 0
INITIALIZE_REG_R2 = 0
INITIALIZE_REG_R3 = 0
INITIALIZE_REG_R4 = 0
INITIALIZE_REG_R5 = 0
INITIALIZE_REG_R6 = 0
INITIALIZE_REG_R7 = 0
INITIALIZE_REG_R8 = 0
INITIALIZE_REG_R9 = 0
INITIALIZE_REG_R10 = 0
INITIALIZE_REG_R11 = 0
INITIALIZE_REG_R12 = 0

##################################################################################################
#
##################################################################################################

MAX_INSTR_SIZE = 4
VIEW_MEMORY_DUMP_RANGE = 16
PRINT_TO_CONSOL = 0
PRINT_DASM_DECOMPOSED_PC = 0
PRINT_EMULATION_LOG = 0

program_exit = False
g_current_memory_view_frame_number = 0

TEST_CODE = "\x00\x00\x00\x00\x00\x00\x00\x01"

EMUL_FUNCTION_NOP = 0
EMUL_FUNCTION_STRLEN = 1
EMUL_FUNCTION_AES_CRYPT = 2

EMUL_ADDR_FUNCTIONS_GLOBAL_TAB = {}
# EMUL_ADDR_FUNCTIONS_GLOBAL_TAB[0xFFFFFFFFF] = EMUL_FUNCTION_STRLEN

##################################################################################################
# .CODE
##################################################################################################

IN_UC_ARCH = UC_ARCH_ARM
IN_CS_MODE = CS_ARCH_ARM

if IS_THUMB_MODE == 0:
    IN_UC_ARCH_MODE = UC_MODE_ARM
    IN_CS_ARCH_MODE = CS_MODE_ARM
    print("Using ARM - ARM mode")
else:
    IN_UC_ARCH_MODE = UC_MODE_THUMB
    IN_CS_ARCH_MODE = CS_MODE_THUMB
    print("Using ARM - THUMB mode")

print("Imagebase: 0x" + '{:08X}'.format(IMAGEBASE) + " Entrypoint: 0x" + '{:08X}'.format(ENTRYPOINT))

lock = threading.Lock()

_python3 = sys.version_info.major == 3


def to_hex(s):
    if _python3:
        return " ".join("0x{0:02x}".format(c) for c in s)
    else:
        return " ".join("0x{0:02x}".format(ord(c)) for c in s)


def to_hex2(s):
    if _python3:
        r = "".join("{0:02x}".format(c) for c in s)
    else:
        r = "".join("{0:02x}".format(ord(c)) for c in s)
    while r[0] == '0': r = r[1:]
    return r


def to_x(s):
    from struct import pack
    if not s: return '0'
    x = pack(">q", s)
    while x[0] in ('\0', 0): x = x[1:]
    return to_hex2(x)


def to_x_32(s):
    from struct import pack
    if not s: return '0'
    x = pack(">i", s)
    while x[0] in ('\0', 0): x = x[1:]
    return to_hex2(x)


def BREAK_HERE():
    pdb.set_trace()
    return


class Dasm(object):
    def __init__(self):
        self.abc = ""
        self._set_dasm_mode()

    def _set_dasm_mode(self):
        self.md_lite = Cs(IN_CS_MODE, IN_CS_ARCH_MODE)
        self.md_lite.detail = True
        self.md_lite.imm_unsigned = True
        self.md_lite.syntax = CS_OPT_SYNTAX_NOREGNAME

        self.md_full = Cs(IN_CS_MODE, IN_CS_ARCH_MODE)
        self.md_full.detail = True
        self.md_full.imm_unsigned = True
        self.md_full.syntax = CS_OPT_SYNTAX_NOREGNAME

    def print_insn_detail(self, insn):
        print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

    def print_detail(self, insn):
        # print address, mnemonic and operands
        print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

        # "data" instruction generated by SKIPDATA option has no detail
        if insn.id == 0:
            return

        #
        # example from http://www.capstone-engine.org/lang_python.html
        #
        if len(insn.regs_read) > 0:
            print("\tImplicit registers read: "),
            for r in insn.regs_read:
                print("%s \n" % insn.reg_name(r))

        if len(insn.regs_write) > 0:
            print("\tImplicit registers write: "),
            for r in insn.regs_write:
                print("%s \n" % insn.reg_name(r))

        if len(insn.operands) > 0:
            print("\top_count: %u" % len(insn.operands))
            c = 0
            for i in insn.operands:
                if i.type == ARM_OP_REG:
                    print("\t\toperands[%u].type: REG = %s" % (c, insn.reg_name(i.reg)))
                if i.type == ARM_OP_IMM:
                    print("\t\toperands[%u].type: IMM = 0x%s" % (c, to_x_32(i.imm)))
                if i.type == ARM_OP_PIMM:
                    print("\t\toperands[%u].type: P-IMM = %u" % (c, i.imm))
                if i.type == ARM_OP_CIMM:
                    print("\t\toperands[%u].type: C-IMM = %u" % (c, i.imm))
                if i.type == ARM_OP_FP:
                    print("\t\toperands[%u].type: FP = %f" % (c, i.fp))
                if i.type == ARM_OP_SYSREG:
                    print("\t\toperands[%u].type: SYSREG = %u" % (c, i.reg))
                if i.type == ARM_OP_SETEND:
                    if i.setend == ARM_SETEND_BE:
                        print("\t\toperands[%u].type: SETEND = be" % c)
                    else:
                        print("\t\toperands[%u].type: SETEND = le" % c)
                if i.type == ARM_OP_MEM:
                    print("\t\toperands[%u].type: MEM" % c)
                    if i.mem.base != 0:
                        print("\t\t\toperands[%u].mem.base: REG = %s" % (c, insn.reg_name(i.mem.base)))
                    if i.mem.index != 0:
                        print("\t\t\toperands[%u].mem.index: REG = %s" % (c, insn.reg_name(i.mem.index)))
                    if i.mem.scale != 1:
                        print("\t\t\toperands[%u].mem.scale: %u" % (c, i.mem.scale))
                    if i.mem.disp != 0:
                        print("\t\t\toperands[%u].mem.disp: 0x%s" % (c, to_x_32(i.mem.disp)))

                if i.shift.type != ARM_SFT_INVALID and i.shift.value:
                    print("\t\t\tShift: %u = %u" % (i.shift.type, i.shift.value))
                if i.vector_index != -1:
                    print("\t\t\toperands[%u].vector_index = %u" % (c, i.vector_index))
                if i.subtracted:
                    print("\t\t\toperands[%u].subtracted = True" % c)

                c += 1

        if insn.update_flags:
            print("\tUpdate-flags: True")
        if insn.writeback:
            print("\tWrite-back: True")
        if not insn.cc in [ARM_CC_AL, ARM_CC_INVALID]:
            print("\tCode condition: %u" % insn.cc)
        if insn.cps_mode:
            print("\tCPSI-mode: %u" % (insn.cps_mode))
        if insn.cps_flag:
            print("\tCPSI-flag: %u" % (insn.cps_flag))
        if insn.vector_data:
            print("\tVector-data: %u" % (insn.vector_data))
        if insn.vector_size:
            print("\tVector-size: %u" % (insn.vector_size))
        if insn.usermode:
            print("\tUser-mode: True")
        if insn.mem_barrier:
            print("\tMemory-barrier: %u" % (insn.mem_barrier))

    def disasm_buffer_light(self, base_addr, buf, dasm_mode):
        self.md_lite.mode = dasm_mode
        address = size = mnemonic = op_str = 0
        try:
            for (address, size, mnemonic, op_str) in self.md_lite.disasm_lite(buf, base_addr, 1):
                break
        except CsError as e:
            assert (False)
            print("ERROR: %s" % e)

        return address, size, mnemonic, op_str

    def disasm_buffer_full(self, base_addr, buf, dasm_mode):
        self.md_full.mode = dasm_mode
        try:
            for insn in self.md_full.disasm(buf, base_addr, 1):
                self.print_detail(insn)
        except CsError as e:
            assert (False)
            print("ERROR: %s" % e)
        return


class EmulatorCore(object):
    def __init__(self):
        self.filename = ""
        self.last_error = ""
        self.disasm_number_of_lines = 0
        self.file_data = b''
        self.threads = []
        self._create_objects()
        self.emul_data_waiting = False
        self.update_mem_view = False
        self.update_dasm_view = False
        self.update_register_view = False
        self.last_emul_ip = 0
        self.tracking_curr_instr_ip = 0
        self.highlight_line_num = -1
        self.wait_for_user_input = False
        self.go_emul = False
        self.emulator_running = False
        self.break_run = False
        self.mem_view1_addr = 0
        self.mem_view1_range = 0
        self.mem_view1_buffer = b""
        self.mem_view2_addr = 0
        self.mem_view2_range = 0
        self.mem_view2_buffer = b""
        self.run_counter = 0
        self.bp_settings_dict = {}
        self.dasm_listing_dict = collections.OrderedDict()
        self.last_hook_regs_data = {}
        self.mem_map_region_rwx = []
        self.disasm_mode = None

    def set_disasm_number_of_lines(self, ln_count):
        self.disasm_number_of_lines = ln_count

    def _create_objects(self):
        self.dasm = Dasm()

    def load_binary_stream(self, bin_stream):
        self.file_data = bin_stream
        return len(bin_stream)

    def load_input_file(self, fname):
        if fname == "":
            return 0

        with open(fname, 'rb') as f:
            self.file_data = f.read()

        return len(self.file_data)

    def fetch_org_bytes(self, offset, fetch_limit):
        if (offset + fetch_limit) < len(self.file_data):
            return self.file_data[offset: offset + fetch_limit]
        elif offset < len(self.file_data):
            rest = len(self.file_data) - offset
            return self.file_data[offset: offset + rest]
        else:
            return ""

    def is_emul_data_waiting(self):
        global lock
        with lock:
            return self.emul_data_waiting

    def reset_emul_data_waiting(self):
        global lock
        with lock:
            self.emul_data_waiting = False

    def set_emul_data_waiting(self):
        global lock
        with lock:
            self.emul_data_waiting = True

    def set_new_memory_view_addr_on_window_number(self, addr, window_view):
        global lock
        with lock:
            if window_view == 0:
                self.mem_view1_addr = addr
            elif window_view == 1:
                self.mem_view2_addr = addr

    def set_mem_view_range(self, r, frame_num):
        if frame_num == 0:
            self.mem_view1_range = r
        elif frame_num == 1:
            self.mem_view2_range = r
        else:
            assert (False)

    def get_mem_view1_addr_data(self):
        global lock
        with lock:
            return self.mem_view1_addr, self.mem_view1_buffer

    def get_mem_view2_addr_data(self):
        global lock
        with lock:
            return self.mem_view2_addr, self.mem_view2_buffer

    def get_disasm_listing_dict(self):
        return self.dasm_listing_dict

    def get_highlight_line_num(self):
        if self.highlight_line_num == -1:
            return -1
        # text line number start from 1
        return self.highlight_line_num + 1

    def is_wait_for_user_input(self):
        global lock
        with lock:
            return self.wait_for_user_input

    def reset_wait_for_user_input(self):
        global lock
        with lock:
            self.wait_for_user_input = False

    def set_wait_for_user_input(self):
        global lock
        with lock:
            self.wait_for_user_input = True

    def is_update_mem_view(self):
        global lock
        with lock:
            return self.update_mem_view

    def reset_update_mem_view(self):
        global lock
        with lock:
            self.update_mem_view = False

    def set_update_mem_view(self):
        global lock
        with lock:
            self.update_mem_view = True

    def is_dasm_view_update(self):
        global lock
        with lock:
            return self.update_dasm_view

    def reset_dasm_view_update(self):
        global lock
        with lock:
            self.update_dasm_view = False

    def set_dasm_view_update(self):
        global lock
        with lock:
            self.update_dasm_view = True

    def is_register_view_update(self):
        global lock
        with lock:
            return self.update_register_view

    def reset_update_register_view(self):
        global lock
        with lock:
            self.update_register_view = False

    def set_update_register_view(self):
        global lock
        with lock:
            self.update_register_view = True

    def dasm_listing_index_to_addr(self, i):
        global lock
        with lock:
            j = 0
            for addr_key in self.dasm_listing_dict:
                if i == j:
                    return True, addr_key
                j = j + 1
            return False, 0

    def reset_run_counter(self):
        self.run_counter = 0

    def inc_run_counter(self):
        self.run_counter = self.run_counter + 1

    def set_register_data(self, reg_name, reg_val):
        if not self.is_wait_for_user_input():
            return False

        if reg_name == 'r0':
            self.uc.reg_write(UC_ARM_REG_R0, reg_val)
            return True
        elif reg_name == 'r1':
            self.uc.reg_write(UC_ARM_REG_R1, reg_val)
            return True
        elif reg_name == 'r2':
            self.uc.reg_write(UC_ARM_REG_R2, reg_val)
            return True
        elif reg_name == 'r3':
            self.uc.reg_write(UC_ARM_REG_R3, reg_val)
            return True
        elif reg_name == 'r4':
            self.uc.reg_write(UC_ARM_REG_R4, reg_val)
            return True
        elif reg_name == 'r5':
            self.uc.reg_write(UC_ARM_REG_R5, reg_val)
            return True
        elif reg_name == 'r6':
            self.uc.reg_write(UC_ARM_REG_R6, reg_val)
            return True
        elif reg_name == 'r7':
            self.uc.reg_write(UC_ARM_REG_R7, reg_val)
            return True
        elif reg_name == 'r8':
            self.uc.reg_write(UC_ARM_REG_R8, reg_val)
            return True
        elif reg_name == 'r9':
            self.uc.reg_write(UC_ARM_REG_R9, reg_val)
            return True
        elif reg_name == 'r10' or reg_name == 'sl':
            self.uc.reg_write(UC_ARM_REG_R10, reg_val)
            return True
        elif reg_name == 'r11':
            self.uc.reg_write(UC_ARM_REG_R11, reg_val)
            return True
        elif reg_name == 'r12':
            self.uc.reg_write(UC_ARM_REG_R12, reg_val)
            return True
        elif reg_name == 'r13' or reg_name == 'sp':
            self.uc.reg_write(UC_ARM_REG_R13, reg_val)
            return True
        elif reg_name == 'r14' or reg_name == 'lr':
            self.uc.reg_write(UC_ARM_REG_R14, reg_val)
            return True
        elif reg_name == 'r15' or reg_name == 'pc':
            self.uc.reg_write(UC_ARM_REG_R15, reg_val)
            return True
        elif reg_name == 'psr':
            self.uc.reg_write(UC_ARM_REG_CPSR, reg_val)
            return True

        return False

    def get_register_last_data(self):
        return self.last_hook_regs_data

    def _save_register_last_data(self):
        assert (self.is_wait_for_user_input() == False)

        r0 = self.uc.reg_read(UC_ARM_REG_R0)
        r1 = self.uc.reg_read(UC_ARM_REG_R1)
        r2 = self.uc.reg_read(UC_ARM_REG_R2)
        r3 = self.uc.reg_read(UC_ARM_REG_R3)
        r4 = self.uc.reg_read(UC_ARM_REG_R4)
        r5 = self.uc.reg_read(UC_ARM_REG_R5)
        r6 = self.uc.reg_read(UC_ARM_REG_R6)
        r7 = self.uc.reg_read(UC_ARM_REG_R7)
        r8 = self.uc.reg_read(UC_ARM_REG_R8)
        r9 = self.uc.reg_read(UC_ARM_REG_R9)
        sl = r10 = self.uc.reg_read(UC_ARM_REG_R10)
        fp = r11 = self.uc.reg_read(UC_ARM_REG_R11)
        ip = r12 = self.uc.reg_read(UC_ARM_REG_R12)
        sp = r13 = self.uc.reg_read(UC_ARM_REG_R13)
        lr = r14 = self.uc.reg_read(UC_ARM_REG_R14)
        pc = r15 = self.uc.reg_read(UC_ARM_REG_R15)
        psr = self.uc.reg_read(UC_ARM_REG_CPSR)

        self.last_hook_regs_data = {}
        self.last_hook_regs_data['r0'] = r0
        self.last_hook_regs_data['r1'] = r1
        self.last_hook_regs_data['r2'] = r2
        self.last_hook_regs_data['r3'] = r3
        self.last_hook_regs_data['r4'] = r4
        self.last_hook_regs_data['r5'] = r5
        self.last_hook_regs_data['r6'] = r6
        self.last_hook_regs_data['r7'] = r7
        self.last_hook_regs_data['r8'] = r8
        self.last_hook_regs_data['r9'] = r9
        self.last_hook_regs_data['r10'] = r10
        self.last_hook_regs_data['r11'] = r11
        self.last_hook_regs_data['r12'] = r12
        self.last_hook_regs_data['sp'] = sp
        self.last_hook_regs_data['lr'] = lr
        self.last_hook_regs_data['pc'] = pc
        self.last_hook_regs_data['psr'] = psr

    def get_register_data(self):
        reg_data = {}
        if not self.is_wait_for_user_input():
            return reg_data

        r0 = self.uc.reg_read(UC_ARM_REG_R0)
        r1 = self.uc.reg_read(UC_ARM_REG_R1)
        r2 = self.uc.reg_read(UC_ARM_REG_R2)
        r3 = self.uc.reg_read(UC_ARM_REG_R3)
        r4 = self.uc.reg_read(UC_ARM_REG_R4)
        r5 = self.uc.reg_read(UC_ARM_REG_R5)
        r6 = self.uc.reg_read(UC_ARM_REG_R6)
        r7 = self.uc.reg_read(UC_ARM_REG_R7)
        r8 = self.uc.reg_read(UC_ARM_REG_R8)
        r9 = self.uc.reg_read(UC_ARM_REG_R9)
        sl = r10 = self.uc.reg_read(UC_ARM_REG_R10)
        fp = r11 = self.uc.reg_read(UC_ARM_REG_R11)
        ip = r12 = self.uc.reg_read(UC_ARM_REG_R12)
        sp = r13 = self.uc.reg_read(UC_ARM_REG_R13)
        lr = r14 = self.uc.reg_read(UC_ARM_REG_R14)
        pc = r15 = self.uc.reg_read(UC_ARM_REG_R15)
        psr = self.uc.reg_read(UC_ARM_REG_CPSR)

        reg_data['r0'] = r0
        reg_data['r1'] = r1
        reg_data['r2'] = r2
        reg_data['r3'] = r3
        reg_data['r4'] = r4
        reg_data['r5'] = r5
        reg_data['r6'] = r6
        reg_data['r7'] = r7
        reg_data['r8'] = r8
        reg_data['r9'] = r9
        reg_data['r10'] = r10
        reg_data['r11'] = r11
        reg_data['r12'] = r12
        reg_data['sp'] = sp
        reg_data['lr'] = lr
        reg_data['pc'] = pc
        reg_data['psr'] = psr
        return reg_data

    def set_break_run(self):
        if self.is_emulator_running() and self.is_wait_for_user_input() == False:
            self.break_run = True

    def is_emulator_running(self):
        return self.emulator_running

    def stop_emulator(self):
        if self.is_emulator_running() and not self.is_emul_data_waiting() and self.is_wait_for_user_input():
            self.uc.emu_stop()
            self.reset_wait_for_user_input()

    def gogo_emulator(self):
        if self.is_emulator_running() and not self.is_emul_data_waiting() and self.is_wait_for_user_input():
            self.go_emul = True
            self.reset_wait_for_user_input()

    def single_step_emulator(self):
        if self.is_emulator_running() and not self.is_emul_data_waiting() and self.is_wait_for_user_input():
            self.reset_wait_for_user_input()

    def worker(self):
        print ("Emulator start: %s" % (time.ctime(time.time())))
        self.set_emul_syscall_address_table()
        self.run_emulator()
        self.reset_emul()

    def reset_emul(self):
        self.emulator_running = False
        self.threads = []
        self.reset_emul_data_waiting()
        self.reset_update_mem_view()
        self.reset_dasm_view_update()
        self.reset_update_register_view()
        self.last_emul_ip = 0
        self.tracking_curr_instr_ip = 0
        self.highlight_line_num = -1
        self.go_emul = False
        self.break_run = False
        self.mem_view1_addr = 0
        self.mem_view1_buffer = b""
        self.mem_view2_addr = 0
        self.mem_view2_buffer = b""
        self.dasm_listing_dict = collections.OrderedDict()
        self.mem_map_region_rwx = []

    def start_emul_thread(self):
        self.emulator_running = True
        self.last_error = ""

        t = threading.Thread(target=self.worker)
        self.threads.append(t)
        t.start()

    def read_emul_memory_range(self, address, mem_size):
        emul_mem = self.uc.mem_read(address, mem_size)
        return emul_mem

    def write_test_data(self):
        if self.is_wait_for_user_input():
            pass
            # bemem = b"\x00"
            # self.uc.mem_write(self.stack_address, bemem)
            # self.uc.mem_write(IMAGEBASE, b"\x31\x22")

    def get_dump_memory(self, dump_begin, dump_range):

        if not self.is_wait_for_user_input():
            return

        buffer = b""
        ba = bytearray()
        if dump_range == 0:
            return ""
        try:
            ba = self.read_emul_memory_range(dump_begin, dump_range)
        except UcError as e:
            if e.errno == UC_ERR_FETCH_UNMAPPED:
                print("get_dump_memory error")

        for i in range(len(ba)):
            b = ba[i]
            buffer += struct.pack('B', b)

        return buffer

    def write_byte_at_memory_addr(self, target_addr, nibble, mask):
        if self.is_wait_for_user_input():
            mem_ba = self.uc.mem_read(target_addr, 1)
            if len(mem_ba) == 0:
                assert (False)
                return

            b = mem_ba[0]
            if mask == 0x0F:
                nn = (nibble << 4)
                print (hex(b))
                b = nn | (b & 0x0F)
            elif mask == 0xF0:
                b = (b & 0xF0) | (nibble & 0x0F)
            else:
                return
            s = b""
            s += struct.pack('B', b)
            self.uc.mem_write(target_addr, s)

    def reload_dasm_listing(self):
        global program_exit
        if program_exit:
            return False
        if not self.is_wait_for_user_input():
            return False

        dasm_listing_top_addr = 0
        if len(self.dasm_listing_dict):
            for key in self.dasm_listing_dict:
                dasm_listing_top_addr = key
                break
        else:
            return False

        self.update_dasm_listing(dasm_listing_top_addr, self.last_emul_ip, self.disasm_mode)
        return True

    def get_dasm_listing_first_addr(self):
        first_addr = None
        for key in self.dasm_listing_dict:
            first_addr = key
            break
        return first_addr

    def get_dasm_listing_last_addr(self):
        last_addr = None
        for key in self.dasm_listing_dict:
            last_addr = key
        return last_addr

    def update_buffer_view_memory1(self):
        self.mem_view1_buffer = b""
        ba = bytearray()
        if self.mem_view1_range == 0:
            return
        try:
            ba = self.read_emul_memory_range(self.mem_view1_addr, self.mem_view1_range)
        except UcError as e:
            if e.errno == UC_ERR_FETCH_UNMAPPED:
                print("update_view_memory1 error")

        for i in range(len(ba)):
            b = ba[i]
            self.mem_view1_buffer += struct.pack('B', b)

    def update_buffer_view_memory2(self):
        self.mem_view2_buffer = b""
        ba = bytearray()
        if self.mem_view2_range == 0:
            return
        try:
            ba = self.read_emul_memory_range(self.mem_view2_addr, self.mem_view2_range)
        except UcError as e:
            if e.errno == UC_ERR_FETCH_UNMAPPED:
                print("update_view_memory2 error")

        for i in range(len(ba)):
            b = ba[i]
            self.mem_view2_buffer += struct.pack('B', b)

    def update_dasm_listing(self, dasm_listing_view_top_first_addr, ip_address, dasm_mode):
        global PRINT_TO_CONSOL
        buffer = self.read_emul_memory_range(dasm_listing_view_top_first_addr,
                                             self.disasm_number_of_lines * MAX_INSTR_SIZE)
        buffer_str = b""
        for i in range(len(buffer)):
            b = buffer[i]
            buffer_str += struct.pack('B', b)

        self.dasm_listing_dict = collections.OrderedDict()
        curr_addr = dasm_listing_view_top_first_addr
        offset = 0
        self.highlight_line_num = -1

        for ln in range(self.disasm_number_of_lines):
            t = self.dasm.disasm_buffer_light(curr_addr, buffer_str[offset:], dasm_mode)
            (ln_dasm_address, inst_size, mnemonic, op_str) = t
            if inst_size == 0:
                if len(buffer_str[offset:]) >= 4:
                    inst_size = 4
                    ln_dasm_address = curr_addr
                    mnemonic = ""
                    op_str = ""
                else:
                    break

            if ln_dasm_address == ip_address:
                self.highlight_line_num = ln
                if PRINT_DASM_DECOMPOSED_PC:
                    self.dasm.disasm_buffer_full(curr_addr, buffer_str[offset:], dasm_mode)

            hex_str = ""
            for j in range(inst_size):
                b = buffer_str[offset + j]
                byte_str = '{:02X}'.format(ord(b))
                hex_str += byte_str
            inst_str = ""
            inst_str = "{0}{1}{2}".format(mnemonic, str(" "), op_str)

            # pdb.set_trace()

            addr_str = '{:08X}'.format(ln_dasm_address)
            line = addr_str + "    " + hex_str.ljust(8) + "    " + inst_str

            if PRINT_TO_CONSOL:
                print(line)

            # replace address with syscall name
            emul_syscall_str = self.addr_to_emul_syscall_instr_str(ln_dasm_address)
            if emul_syscall_str != "":
                addr_str = '{:08X}'.format(ln_dasm_address)
                line = addr_str + "    " + hex_str.ljust(8) + "    " + "bl " + emul_syscall_str

            self.dasm_listing_dict[curr_addr] = line

            offset += inst_size
            curr_addr += inst_size

    def get_last_error(self):
        return self.last_error

    def toggle_bp_settings(self, bp_addr, bp_state):
        global lock
        with lock:
            self.bp_settings_dict[bp_addr] = bp_state

    def get_bp_settings(self):
        global lock
        with lock:
            return self.bp_settings_dict

    def get_bp_settings_for_addr(self, bp_addr):
        global lock
        with lock:
            for key_addr in self.bp_settings_dict:
                if key_addr == bp_addr:
                    return True, self.bp_settings_dict[key_addr]
            return False, 0

    def del_bp_addr(self, bp_addr):
        global lock
        with lock:
            for key in self.bp_settings_dict:
                if bp_addr == key:
                    self.bp_settings_dict.pop(key, None)
                    return 1
            return 0

    def del_all_bp_addr(self):
        l = len(self.bp_settings_dict)
        self.bp_settings_dict = {}
        return l

    def reload_dasm_listing_with_unassemble_from_addr(self, unasm_begin):
        self.update_dasm_listing(unasm_begin, self.tracking_curr_instr_ip, self.disasm_mode)

    def is_mem_region_mapped(self, mem_addr_test):
        for i in range(len(self.mem_map_region_rwx)):
            (mem_begin, mem_range) = self.mem_map_region_rwx[i]
            if mem_begin <= mem_addr_test < (mem_begin + mem_range):
                return True
        return False

    def find_prev_mem_begin_region(self, curr_addr):
        ll = self.mem_map_region_rwx
        ll = sorted(ll)
        for i in range(len(ll)):
            (mem_begin, mem_range) = ll[i]
            if mem_begin <= curr_addr < (mem_begin + mem_range):
                if i == 0:
                    (mem_begin, mem_range) = ll[i]
                    return mem_begin
                else:
                    (mem_begin, mem_range) = ll[i - 1]
                    return mem_begin
        return None

    def find_mem_region_from_addr(self, curr_addr):
        ll = self.mem_map_region_rwx
        ll = sorted(ll)
        for i in range(len(ll)):
            (mem_begin, mem_range) = ll[i]
            if mem_begin <= curr_addr < (mem_begin + mem_range):
                (mem_begin, mem_range) = ll[i]
                return mem_begin, mem_range
        return None, None

    # callback for tracing instructions
    def all_instr_hook_code(self, uc, ip_address, size, user_data):
        global program_exit
        if program_exit:
            return False

        self.tracking_curr_instr_ip = ip_address
        self._save_register_last_data()

        # use Arm mode by default
        self.disasm_mode = CS_MODE_ARM
        if self.uc.query(UC_QUERY_MODE) == UC_MODE_THUMB:
            self.disasm_mode = CS_MODE_THUMB
            if PRINT_EMULATION_LOG:
                print(">> THUMB mode on")

        if ip_address in self.bp_settings_dict:
            # BREAK_HERE()
            print(">>> Breakpoint hit at 0x%x, instruction size = %u" % (ip_address, size))
            self.go_emul = False

        elif self.break_run:
            self.go_emul = False
            self.break_run = False

        elif self.go_emul:
            if PRINT_EMULATION_LOG:
                print(">>> Tracing instruction at 0x%x, instruction size = %u" % (ip_address, size))
            self.last_emul_ip = ip_address
            return True

        if PRINT_EMULATION_LOG:
            print(">>> Tracing instruction at 0x%x, instruction size = %u" % (ip_address, size))

        dasm_listing_top_addr = 0
        if ip_address in self.dasm_listing_dict:
            for key in self.dasm_listing_dict:
                dasm_listing_top_addr = key
                break
        else:
            dasm_listing_top_addr = ip_address

        #
        #
        #
        self.update_dasm_listing(dasm_listing_top_addr, ip_address, self.disasm_mode)
        self.update_buffer_view_memory1()
        self.update_buffer_view_memory2()

        self.set_wait_for_user_input()
        self.set_emul_data_waiting()
        while self.is_emul_data_waiting():
            time.sleep(0.01)

        #
        # wait for user input
        #
        self.last_emul_ip = ip_address

        while self.is_wait_for_user_input():
            time.sleep(0.01)
            if program_exit:
                return False

        self.emul_syscall(ip_address)

        return True

    def emul_syscall(self, ip_address):

        if ip_address in self.emul_syscall_addr_table:
            syscall_number = self.emul_syscall_addr_table[ip_address]
            if syscall_number == EMUL_FUNCTION_NOP:
                pass

            elif syscall_number == EMUL_FUNCTION_STRLEN:
                self.emul_function_strlen()

            elif syscall_number == EMUL_FUNCTION_AES_CRYPT:
                assert False

            else:
                assert False

            self.skip_current_instruction()

    def emul_function_strlen(self):
        r0 = self.uc.reg_read(UC_ARM_REG_R0)
        if not self.is_mem_region_mapped(r0):
            assert False
            return

        (mem_begin, mem_range) = self.find_mem_region_from_addr(r0)
        if mem_begin is None and mem_range is None:
            assert False
            return

        rest_size = (mem_begin + mem_range) - r0
        buff = self.read_emul_memory_range(r0, rest_size)
        i = 0
        for i in range(len(buff)):
            c = buff[i]
            if c == 0x0:
                break
            i += 1
        self.uc.reg_write(UC_ARM_REG_R0, i)

    def skip_current_instruction(self):
        pc = r15 = self.uc.reg_read(UC_ARM_REG_R15)
        if self.uc.query(UC_QUERY_MODE) == UC_MODE_THUMB:
            pc += 2
        else:
            pc += 4
        self.uc.reg_write(UC_ARM_REG_R15, pc)

    # callback for tracing basic blocks
    def basic_block_hook_block(self, uc, address, size, user_data):
        if PRINT_EMULATION_LOG:
            print(">>> Tracing basic block at 0x%x, block size = 0x%x" % (address, size))

    # callback for tracing memory access (READ or WRITE)
    def hook_mem_access(self, uc, access, address, size, value, user_data):
        if access == UC_MEM_WRITE:
            if PRINT_EMULATION_LOG:
                print(">>> Memory is being WRITE at 0x%x, data size = %u, data value = 0x%x" % (address, size, value))
        else:  # READ
            if PRINT_EMULATION_LOG:
                print(">>> Memory is being READ at 0x%x, data size = %u" % (address, size))

    def hook_mem_read_unmapped(self, uc, access, address, size, value, user_data):
        print("UC_HOOK_MEM_READ_UNMAPPED at 0x%x access %d" % (address, access))
        return False

    # callback for tracing invalid memory access (READ/WRITE/EXEC)
    def hook_mem_invalid(self, uc, access, address, size, value, user_data):
        access_memory_str = ""
        if access == UC_MEM_READ_UNMAPPED:
            print("!!! Invalid Memory is being READ at 0x%x, data size = %u" % (address, size))
            access_memory_str = "UC_MEM_READ_UNMAPPED"
        elif access == UC_MEM_WRITE_UNMAPPED:
            access_memory_str = "UC_MEM_WRITE_UNMAPPED"
        elif access == UC_MEM_FETCH_PROT:
            access_memory_str = "UC_MEM_FETCH_PROT"
        elif access == UC_MEM_WRITE_PROT:
            access_memory_str = "UC_MEM_WRITE_PROT"
        elif access == UC_MEM_READ_PROT:
            access_memory_str = "UC_MEM_READ_PROT"

        print("!!! Invalid Memory is being at 0x%x, data size = %u" % (address, size))
        print (access_memory_str)
        # pdb.set_trace()
        self.last_error = "UC_HOOK_MEM_INVALID at 0x%x access %d" % (address, access)
        print (self.last_error)
        return False

    # callback for tracing Linux interrupt
    def hook_intr(self, uc, intno, user_data):
        # only handle Linux syscall
        rip = self.uc.reg_read(UC_ARM_REG_IP)
        if intno != 0x80:
            print("=== 0x%x: got interrupt %x, quit" % (rip, intno))
            self.uc.emu_stop()
            return
        eax = self.uc.reg_read(UC_ARM_REG_R0)
        print(">>> 0x%x: interrupt 0x%x, R0 = 0x%x" % (rip, intno, eax))

    def addr_to_emul_syscall_instr_str(self, ip_address):
        if ip_address in self.emul_syscall_addr_table:
            syscall_number = self.emul_syscall_addr_table[ip_address]
            if syscall_number == EMUL_FUNCTION_NOP:
                return "emul_nop"
            elif syscall_number == EMUL_FUNCTION_STRLEN:
                return "emul_strlen"
            elif syscall_number == EMUL_FUNCTION_AES_CRYPT:
                return "aes_crypt"
            else:
                assert (False)
        return ""

    def set_emul_syscall_address_table(self):
        global EMUL_ADDR_FUNCTIONS_GLOBAL_TAB

        self.emul_syscall_addr_table = {}
        for key, value in EMUL_ADDR_FUNCTIONS_GLOBAL_TAB.iteritems():
            self.emul_syscall_addr_table[key] = value

    def run_emulator(self):
        try:

            self.mem_map_region_rwx = []
            self.inc_run_counter()

            # Initialize emulator in ARM mode
            self.uc = Uc(IN_UC_ARCH, IN_UC_ARCH_MODE)

            self.mem_size = 0
            i = len(self.file_data) // (1024 * 1024)
            self.mem_size = (1024 * 1024) + (i * (1024 * 1024))

            # map memory for this emulation
            self.uc.mem_map(IMAGEBASE, self.mem_size)

            # map stack memory
            self.stack_address = IMAGEBASE + self.mem_size
            self.stack_size = (1024 * 1024) * 2
            self.uc.mem_map(self.stack_address, self.stack_size)

            # append mapped regions to the list (addr, range)
            self.mem_map_region_rwx.append((IMAGEBASE, self.mem_size))
            self.mem_map_region_rwx.append((self.stack_address, self.stack_size))

            # write machine code to be emulated to memory
            self.uc.mem_write(IMAGEBASE, self.file_data)

            # initialize machine registers
            self.uc.reg_write(UC_ARM_REG_R0, INITIALIZE_REG_R0)
            self.uc.reg_write(UC_ARM_REG_R1, INITIALIZE_REG_R1)
            self.uc.reg_write(UC_ARM_REG_R2, INITIALIZE_REG_R2)
            self.uc.reg_write(UC_ARM_REG_R3, INITIALIZE_REG_R3)
            self.uc.reg_write(UC_ARM_REG_R4, INITIALIZE_REG_R4)
            self.uc.reg_write(UC_ARM_REG_R5, INITIALIZE_REG_R5)
            self.uc.reg_write(UC_ARM_REG_R6, INITIALIZE_REG_R6)
            self.uc.reg_write(UC_ARM_REG_R7, INITIALIZE_REG_R7)
            self.uc.reg_write(UC_ARM_REG_R8, INITIALIZE_REG_R8)
            self.uc.reg_write(UC_ARM_REG_R9, INITIALIZE_REG_R9)
            self.uc.reg_write(UC_ARM_REG_R10, INITIALIZE_REG_R10)
            self.uc.reg_write(UC_ARM_REG_R11, INITIALIZE_REG_R11)
            self.uc.reg_write(UC_ARM_REG_R12, INITIALIZE_REG_R12)

            self.uc.reg_write(UC_ARM_REG_SP, self.stack_address)

            # tracing all basic blocks with customized callback
            self.uc.hook_add(UC_HOOK_BLOCK, self.basic_block_hook_block)

            # tracing all instructions with customized callback
            self.uc.hook_add(UC_HOOK_CODE, self.all_instr_hook_code)
            self.uc.hook_add(UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, self.hook_mem_access)
            self.uc.hook_add(UC_HOOK_MEM_INVALID, self.hook_mem_invalid)
            # self.uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED, self.hook_mem_read_unmapped)
            self.uc.hook_add(UC_HOOK_INTR, self.hook_intr)

            self.mem_view1_addr = IMAGEBASE
            self.mem_view2_addr = self.stack_address

            thumbCorrect = 0
            if IS_THUMB_MODE:
                thumbCorrect = 1
                print("Entrypoint adjusted to thumb")

            # emulate machine code in infinite time
            self.uc.emu_start(IMAGEBASE + ENTRYPOINT + thumbCorrect, IMAGEBASE + self.mem_size - 1)
        except UcError as e:
            if e.errno == UC_ERR_FETCH_UNMAPPED:
                print("!!! about to bail due to bad fetch... here's the data at PC:")
                print("Last IP at 0x%x" % self.last_emul_ip)

                print(binascii.hexlify(self.uc.mem_read(self.uc.reg_read(UC_ARM_REG_IP), 0x8)))
                print("IP at 0x%x" % (self.uc.reg_read(UC_ARM_REG_IP)))
                return

                # print ("Emulator finished")
                # last_ip = '{:08X}'.format(self.uc.reg_read(UC_ARM_REG_IP))
                # print(last_ip)


#
# Command Line
#
class CommandLineWindow(tk.Frame):
    def __init__(self, master=None):
        self.parent = master
        tk.Frame.__init__(self, self.parent, bg='bisque', borderwidth=1, relief="sunken")
        self._create_settings()
        self._create_layout()
        self._create_bindings()

    def _create_settings(self):
        self.history_list = []
        self.history_index = 0
        self.emulator_core = None
        self.font = tkFont.Font(family=FONT_FAMILY, size=FONT_SIZE)

    def _create_layout(self):
        self.textArea = tk.Text(self, wrap=tk.NONE, undo=True,
                                width=1, height=1,
                                relief=tk.SUNKEN, borderwidth=2,
                                highlightthickness=0, insertbackground="white")
        self.textArea.config(font=self.font)
        self.textArea.configure(bg="black", fg=TEXT_COLOR)

        self.cmdEdit = tk.Text(self, wrap=tk.NONE, undo=True,
                               width=1, height=1,
                               relief=tk.SUNKEN, borderwidth=4,
                               highlightthickness=0, insertbackground="white")
        self.cmdEdit.config(font=self.font)
        self.cmdEdit.configure(bg="black", fg=TEXT_COLOR)

        self.scrollbarY = tk.Scrollbar(self, orient=tk.VERTICAL)
        self.scrollbarX = tk.Scrollbar(self, orient=tk.HORIZONTAL)

        self.textArea.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.scrollbarY.grid(row=0, column=1, sticky=(tk.N, tk.S), rowspan=1)
        self.cmdEdit.grid(row=1, column=0, columnspan=2, sticky=(tk.N, tk.S, tk.W, tk.E))

        self.rowconfigure(0, weight=1)
        self.columnconfigure(0, weight=1)

        self.textArea.configure(yscrollcommand=self.scrollbarY.set)

        self.scrollbarY.config(command=self.textArea.yview)

    def _create_bindings(self):
        self.cmdEdit.bind('<Return>', self.on_cmd_line_return)
        self.cmdEdit.bind('<Up>', self.on_cmd_key_up)
        self.cmdEdit.bind('<Down>', self.on_cmd_key_down)

    def on_cmd_key_down(self, event):
        prev_cmd = self.get_history_text(self.history_index + 1)
        self.set_text_on_cmd_edit(prev_cmd)

    def on_cmd_key_up(self, event):
        next_cmd = self.get_history_text(self.history_index - 1)
        self.set_text_on_cmd_edit(next_cmd)

    def set_text_on_cmd_edit(self, cmd_text):
        if len(cmd_text) != 0:
            self.cmdEdit.delete(0.0, "end")
            self.cmdEdit.insert(0.0, cmd_text)

    def on_focus_cmd_line(self):
        self.cmdEdit.focus_set()

    def get_history_text(self, index):
        if len(self.history_list) == False:
            return ""
        if index == 0:
            self.history_index = 0
            return self.history_list[0]
        elif index > 0 and index < len(self.history_list):
            self.history_index = index
            return self.history_list[index]
        else:
            return ""

    def add_emulator_core_access(self, emul_uc):
        self.emulator_core = emul_uc

    def cmd_str_to_hex_addr(self, s):
        try:
            s = s.rstrip()
            s = s.lstrip()
            reg_data_dict = self.emulator_core.get_register_data()
            if s in reg_data_dict:
                peek_addr = reg_data_dict[s]
            else:
                if len(s) <= 8:
                    peek_addr = int(s, 16)
                else:
                    peek_addr = eval(s)
        except:
            return (0, False)

        return (peek_addr, True)

    def exec_user_cmd_line(self, cmd_text=""):
        if cmd_text.startswith("d "):
            (dump_expr, ok) = self.cmd_str_to_hex_addr(cmd_text[2:])
            if not ok:
                return
            #
            # update UI
            #
            # pdb.set_trace()
            global g_current_memory_view_frame_number
            self.emulator_core.set_new_memory_view_addr_on_window_number(dump_expr, g_current_memory_view_frame_number)
            if self.emulator_core.is_wait_for_user_input() and not self.emulator_core.is_emul_data_waiting():
                self.emulator_core.set_update_mem_view()

        elif cmd_text.startswith("u "):
            (dump_expr, ok) = self.cmd_str_to_hex_addr(cmd_text[2:])
            if not ok:
                return

            if self.emulator_core.is_wait_for_user_input():
                self.emulator_core.reload_dasm_listing_with_unassemble_from_addr(dump_expr)
                self.emulator_core.set_dasm_view_update()

        elif cmd_text.startswith("bp "):  # set breakpoint
            (peek_addr, ok) = self.cmd_str_to_hex_addr(cmd_text[2:])
            if not ok:
                return

            self.emulator_core.toggle_bp_settings(peek_addr, 1)

            if self.emulator_core.is_wait_for_user_input():
                self.emulator_core.set_dasm_view_update()

        elif cmd_text.startswith("bc *"):  # clear ALL breakpoint
            if self.emulator_core.del_all_bp_addr() != 0:
                if self.emulator_core.is_wait_for_user_input():
                    self.emulator_core.set_dasm_view_update()

        elif cmd_text.startswith("bc "):  # clear breakpoint
            (peek_addr, ok) = self.cmd_str_to_hex_addr(cmd_text[2:])
            if not ok:
                return False

            if self.emulator_core.del_bp_addr(peek_addr) != 0:
                if self.emulator_core.is_wait_for_user_input():
                    self.emulator_core.set_dasm_view_update()

        elif cmd_text.startswith("bl"):
            text_pile = ""
            bp_list = self.emulator_core.get_bp_settings()
            for key in bp_list:
                bp_ip_str = '0x{:08X}'.format(key)
                bp_state_str = format(bp_list[key])
                l = bp_ip_str + " - state: " + bp_state_str
                text_pile += l + "\n"
            self.append_TextArea(text_pile)

        elif cmd_text.startswith("r "):
            words = cmd_text[2:].split()
            if len(words) == 2:
                reg_data_dict = self.emulator_core.get_register_data()
                if words[0] in reg_data_dict:
                    val = int(words[1], 16)
                    if self.emulator_core.is_wait_for_user_input() and self.emulator_core.set_register_data(words[0],
                                                                                                            val) == True:
                        self.emulator_core.set_update_register_view()

        elif cmd_text == "rr":
            if self.emulator_core.is_wait_for_user_input():
                reg_data_dict = self.emulator_core.get_register_data()
                self.print_emul_exit_context(reg_data_dict)

        elif cmd_text.startswith("dump "):
            words = cmd_text[4:].split()
            if len(words) < 2:
                return False
            (dump_addr, ok) = self.cmd_str_to_hex_addr(words[0])
            if ok == False:
                return False
            dump_range = eval(words[1])
            path_begin = cmd_text.find('"')
            if path_begin == - 1:
                return False
            path_begin += 1
            path_end = cmd_text[path_begin:].find('"')
            if path_end == - 1:
                return False
            path_end += path_begin

            dump_filename = cmd_text[path_begin:path_end]
            dump_mem = self.emulator_core.get_dump_memory(dump_addr, dump_range)
            if len(dump_mem):
                dump_file = open(dump_filename, 'wb')
                dump_file.write(dump_mem)
                dump_file.close()
                print(dump_addr, dump_range, dump_filename)

        elif cmd_text.startswith("? "):
            s = cmd_text[1:]
            s = s.rstrip()
            s = s.lstrip()
            txt = str(eval(s))
            self.append_TextArea(txt)

        elif cmd_text.startswith("hex(") and cmd_text.endswith(')'):
            s = cmd_text[4:-1]
            s = s.rstrip()
            s = s.lstrip()
            txt = hex(eval(s))
            self.append_TextArea(txt)

        elif cmd_text == "help":
            commands = ""
            commands += "d <addr>                           - dump memory\n"
            commands += "u <addr>                           - unassemble memory\n"
            commands += "bp <addr>                          - set breakpoint\n"
            commands += "bc <addr>                          - clear breakpoint\n"
            commands += "bl                                 - list breakpoints\n"
            commands += "r <register> <value>               - change register value\n"
            commands += "rr                                 - print registers\n"
            commands += "?                                  - calc expression\n"
            commands += "dump <addr> <range> \"PATH\"       - dump memory range to a file\n"
            commands += "hex("")                            - calc expression format to hex\n"
            self.append_TextArea(commands)

        else:
            return False
        return True

    def append_TextArea(self, append_txt):
        if len(append_txt) == 0:
            return
        txt = self.textArea.get('1.0', tk.END)
        self.textArea.insert(tk.END, "\n" + append_txt)
        self.textArea.see(tk.END)

    def on_cmd_line_return(self, event):
        cmd_text = str(self.cmdEdit.get(0.0, "end"))
        cmd_text = cmd_text.lstrip('\n')
        cmd_text = cmd_text.rstrip('\n')

        if not self.exec_user_cmd_line(cmd_text):
            print ("Command line parse error")

        if len(self.history_list) > 8:
            del self.history_list[0]

        self.history_list.append(cmd_text)
        self.history_index = len(self.history_list)

        self.cmdEdit.delete(0.0, "end")
        pass

    def print_emul_exit_context(self, reg_data):
        self.textArea.delete('1.0', tk.END)
        i = 0
        lines = ""
        for reg_name in sorted(reg_data):
            if i > 0 and (i % 4) == 0:
                lines += "\n"
            reg_val = reg_data[reg_name]
            i += 1
            lines += reg_name.ljust(3) + "  : " + '{:08X}'.format(reg_val) + "  "

        self.textArea.insert(tk.END, lines)


#
# RegisterWindow
#
class RegisterWindow(tk.Frame):
    def __init__(self, master=None):
        self.parent = master
        tk.Frame.__init__(self, self.parent, bg='bisque', borderwidth=1, relief="sunken")

        self._create_settings()
        self._create_layout()

        self._create_token_objects()
        self._draw_data_on_canvas()
        self._create_bindings()

    def _create_layout(self):
        self.canvas = tk.Canvas(self, bg=BACKGROUND_COLOR, relief=tk.SUNKEN)
        self.canvas.config(width=20, height=10)
        # self.canv.config(scrollregion=(0,0,300, 1000))
        self.canvas.config(highlightthickness=0)

        self.sbar = tk.Scrollbar(self, orient=tk.VERTICAL)
        # self.sbar.config(command=self.canv.yview)
        # self.canv.config(yscrollcommand=self.sbar.set)
        self.sbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.canvas.pack(side=tk.LEFT, expand="YES", fill=tk.BOTH)

        self.height = self.canvas.winfo_width()
        self.width = self.canvas.winfo_height()

    def _create_settings(self):
        self.mouse_x, self.mouse_y = 0, 0

        self.reg_names_list = ["r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"]
        self.reg_names_list += ["r9", "r10", "r11", "r12", "sp", "lr", "pc", "psr"]

        # this data is used to keep track of an
        # item being dragged
        self._drag_data = {"x": 0, "y": 0, "item_text": "", "item": None}

        self.refreshPending = False
        self.curr_memory_addr = 0
        self.font = tkFont.Font(family=FONT_FAMILY, size=FONT_SIZE)
        (self.font_width, self.font_height) = (self.font.measure("W"), self.font.metrics("linespace"))
        self.prev_reg_data = {}

    def on_resize(self, event):
        # determine the ratio of old width/height to new width/height
        wscale = float(event.width) / self.width
        hscale = float(event.height) / self.height
        self.width = event.width
        self.height = event.height

        # resize the canvas
        self.config(width=self.width, height=self.height)

    def mouse_click(self, event):
        self.mouse_x, self.mouse_y = event.x, event.y

        canv_click_id = self.canvas.find_withtag(tk.CURRENT)
        tags = self.canvas.gettags(canv_click_id)

    def _create_bindings(self):
        self.bind("<Configure>", self.on_resize)
        self.canvas.bind("<Button-1>", self.mouse_click)

        # add bindings for clicking, dragging and releasing over
        # any object with the "token" tag
        self.canvas.tag_bind("token", "<ButtonPress-1>", self.on_token_button_press)
        self.canvas.tag_bind("token", "<ButtonRelease-1>", self.on_token_button_release)
        self.canvas.tag_bind("token", "<B1-Motion>", self.on_token_motion)
        # self.canvas.bind_all("<MouseWheel>", self.on_mousewheel_del)

    def on_token_button_press(self, event):
        # Being drag of an object record the item and its location
        self._drag_data["item"] = self.canvas.find_closest(event.x, event.y)[0]
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y
        self._drag_data["item_text"] = event.widget.itemcget(tk.CURRENT, "text")
        # coords = self.canvas.coords(tk.CURRENT)

    def on_token_button_release(self, event):
        # End drag of an object reset the drag information
        self._drag_data["item"] = None
        self._drag_data["item_text"] = ""
        self._drag_data["x"] = 0
        self._drag_data["y"] = 0

    def on_token_motion(self, event):
        # Handle dragging of an object compute how much this object has moved
        delta_x = event.x - self._drag_data["x"]
        delta_y = event.y - self._drag_data["y"]
        # move the object the appropriate amount
        self.canvas.move(self._drag_data["item"], delta_x, delta_y)
        # record the new position
        self._drag_data["x"] = event.x
        self._drag_data["y"] = event.y

    def _create_token_objects(self):
        # create a couple movable objects
        margin = 5
        for i in range(len(self.reg_names_list)):
            reg_name = self.reg_names_list[i]
            reg_label = reg_name.ljust(3) + "  : " + '{:08X}'.format(0)
            token_y = i * (self.font_height + 2)
            self._create_token((margin, token_y), reg_label, "token")

    def _create_token(self, coord, reg_name, token_name):
        # Create a token at the given coordinate in the given color

        (x, y) = coord
        self.canvas.create_text(x, y, tags=token_name, text=reg_name, activefill='#99FF00', font=self.font,
                                fill=TEXT_COLOR, anchor="nw")

    def _draw_data_on_canvas(self):
        pass

    def update_register_view(self, curr_reg_data):

        # self.canvas.delete(tk.ALL) # remove all items
        if len(curr_reg_data) == 0:
            return

        reg_tokens = self.canvas.find_withtag("token")

        for i in range(len(self.reg_names_list)):
            reg_color = TEXT_COLOR
            reg_name = self.reg_names_list[i]
            if reg_name in self.prev_reg_data and curr_reg_data[reg_name] != self.prev_reg_data[reg_name]:
                reg_color = "yellow"
            token_text = reg_name.ljust(3) + "  : " + '{:08X}'.format(curr_reg_data[reg_name])
            self.canvas.itemconfig(reg_tokens[i], fill=reg_color, text=token_text)

        self.prev_reg_data = curr_reg_data


#
# MemoryView
#
class MemoryViewWindow(tk.Frame):
    def __init__(self, master=None):
        self.parent = master
        tk.Frame.__init__(self, self.parent, bg='bisque', borderwidth=1, relief="sunken")

        self._create_settings()
        self._create_layout()
        self._create_bindings()
        self._draw_text_data_on_canvas(self.current_dump_addr, self.current_dump_buffer)

    def _create_layout(self):
        self.canvas = tk.Canvas(self, bg=BACKGROUND_COLOR, relief=tk.SUNKEN)
        self.canvas.config(width=20, height=10)
        # self.canv.config(scrollregion=(0,0,300, 1000))
        self.canvas.config(highlightthickness=0)

        self.sbar = tk.Scrollbar(self, orient=tk.VERTICAL)
        # self.sbar.config(command=self.canv.yview)
        # self.canv.config(yscrollcommand=self.sbar.set)
        self.sbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.canvas.pack(side=tk.LEFT, expand="YES", fill=tk.BOTH)

        self.height = self.canvas.winfo_width()
        self.width = self.canvas.winfo_height()

    def _create_settings(self):
        self.current_dump_addr = 0
        self.current_dump_buffer = b""
        self.mouse_x, self.mouse_y = 0, 0
        self.number_of_line = 0
        self.font = tkFont.Font(family=FONT_FAMILY, size=FONT_SIZE)
        (self.font_char_width, self.font_char_height) = (self.font.measure('0'), self.font.metrics("linespace"))
        self.emulator_core = None
        self.highlight_byte_addr_list = []
        self.view_frame_number = -1
        self.cursor_edit_addr = 0
        self.edit_addr_mask = 0x00
        self.hex_tag_prefix = "hex_tag_"
        self.caret_rect_tag = "caret_rect_tag"
        self.address_line_tag = "address_tag_0x"
        self.mouse_click_tags = ()

    def set_view_number(self, v):
        self.view_frame_number = v

    def _create_bindings(self):
        self.bind("<Configure>", self.on_resize)
        self.canvas.bind("<Button-1>", self.click)
        self.bind("<Enter>", self.mouse_pointer_enter)
        self.bind("<Leave>", self.mouse_pointer_leave)

    def on_mousewheel_scroll_up(self, event=None):
        if not self.emulator_core.is_wait_for_user_input():
            return
        prev_addr = self.current_dump_addr
        prev_addr -= (VIEW_MEMORY_DUMP_RANGE * 3)
        if not self.emulator_core.is_mem_region_mapped(prev_addr):
            return
        self.emulator_core.set_new_memory_view_addr_on_window_number(prev_addr, self.view_frame_number)
        if self.emulator_core.is_wait_for_user_input() and not self.emulator_core.is_emul_data_waiting():
            self.emulator_core.set_update_mem_view()

    def on_mousewheel_scroll_down(self, event=None):
        if not self.emulator_core.is_wait_for_user_input():
            return
        next_addr = self.current_dump_addr
        next_addr += (VIEW_MEMORY_DUMP_RANGE * 3)
        if not self.emulator_core.is_mem_region_mapped(next_addr):
            return
        self.emulator_core.set_new_memory_view_addr_on_window_number(next_addr, self.view_frame_number)

        if self.emulator_core.is_wait_for_user_input() and not self.emulator_core.is_emul_data_waiting():
            self.emulator_core.set_update_mem_view()

    def on_mousewheel(self, event=None):
        delta = (event.delta / 120)
        if delta > 0:
            self.on_mousewheel_scroll_up()
        else:
            self.on_mousewheel_scroll_down()

    def mouse_pointer_enter(self, event):
        self.cursor_edit_addr = 0
        self.edit_addr_mask = 0x00
        # self.focus_set() #will be set on mouse click
        self.bind("<KeyPress>", self.key_press_event)

        os = platform.system()
        if os == "Linux":
            self.canvas.bind('<4>', self.on_mousewheel_scroll_up)
            self.canvas.bind('<5>', self.on_mousewheel_scroll_down)
        else:
            # Windows and MacOS
            self.bind("<MouseWheel>", self.on_mousewheel)

    def mouse_pointer_leave(self, event):
        self.cursor_edit_addr = 0
        self.edit_addr_mask = 0x00
        self.unbind("<KeyPress>")

        self.mouse_click_tags = ()
        caret_tag_id = self.canvas.find_withtag(self.caret_rect_tag)
        if len(caret_tag_id) > 0:
            self.canvas.delete(caret_tag_id)

        os = platform.system()
        if os == "Linux":
            self.canvas.unbind('<4>')
            self.canvas.unbind('<5>')
        else:
            # Windows and MacOS
            self.unbind("<MouseWheel>")

    def key_press_event(self, event):
        if event.keysym_num == 0xffc4:  # F7
            return
        if len(self.mouse_click_tags) == 0:
            return

        tag_name = self.mouse_click_tags[0]
        hex_edit_mode = False
        is_valid_char = False
        if tag_name.startswith(self.hex_tag_prefix):
            hex_edit_mode = True
            if ('0' <= event.char <= '9') or \
                    ('a' <= event.char <= 'f') or \
                    ('A' <= event.char <= 'F'):
                is_valid_char = True

        if hex_edit_mode and is_valid_char:
            s = tag_name[len(self.hex_tag_prefix):]
            eb_addr = int(s, 16)

            eb_val = ord(event.char)
            if eb_val >= ord('0') and eb_val <= ord('9'):
                eb_val -= ord('0')
            elif eb_val >= ord('a') and eb_val <= ord('f'):
                eb_val = (eb_val - ord('a')) + 0x0A
            elif eb_val >= ord('A') and eb_val <= ord('F'):
                eb_val = (eb_val - ord('A')) + 0x0A
            else:
                assert (False)
                return

            if self.edit_addr_mask == 0x00:
                mask = 0x0F
            elif self.edit_addr_mask == 0x0F:
                mask = 0xF0
            else:
                assert (False)
                return

            self.emulator_core.write_byte_at_memory_addr(eb_addr, eb_val, mask)
            self.edit_addr_mask = mask

            if self.edit_addr_mask == 0xF0:
                self.reload_view_on_mem_edit_keypress()
                self.move_caret_to_next_addr()
                self.edit_addr_mask = 0x00

    def reload_view_on_mem_edit_keypress(self):
        if self.view_frame_number == 0:
            self.emulator_core.update_buffer_view_memory1()
            view_addr, view_buffer = self.emulator_core.get_mem_view1_addr_data()
        elif self.view_frame_number == 1:
            self.emulator_core.update_buffer_view_memory2()
            view_addr, view_buffer = self.emulator_core.get_mem_view2_addr_data()
        else:
            assert (False)
            return

        self.display_memory_from_single_step(view_addr, view_buffer)
        self.emulator_core.set_dasm_view_update()

    def move_caret_to_next_addr(self):
        if len(self.mouse_click_tags) == 0:
            return
        tag_name = self.mouse_click_tags[0]
        if not tag_name.startswith(self.hex_tag_prefix):
            return
        s = tag_name[len(self.hex_tag_prefix):]
        next_addr = int(s, 16) + 1
        next_tag = self.hex_byte_addr_to_hex_tag(next_addr)
        tag_id = self.canvas.find_withtag(next_tag)
        if len(tag_id) == 0:
            return

        caret_tag_id = self.canvas.find_withtag(self.caret_rect_tag)
        if len(caret_tag_id) > 0:
            self.canvas.delete(caret_tag_id)

        r = self.canvas.create_rectangle(self.canvas.bbox(tag_id[0]), fill="#193300", tags='caret_rect_tag')
        self.canvas.tag_lower(r)

        tags = self.canvas.gettags(tag_id)
        self.mouse_click_tags = tags

    def add_emulator_core_access(self, emul_uc):
        self.emulator_core = emul_uc

    def draw_addr_area(self, dump_addr):

        mem_addr_str = '{:08X}'.format(dump_addr)

        self.addr_rect_pix_width = self.font_char_width * len(mem_addr_str)
        # self.canvas.create_rectangle(0, 0, self.addr_rect_pix_width, self.height, fill=BACKGROUND_COLOR)

        self.number_of_line = self.height // self.font_char_height

        for i in range(self.number_of_line):
            x = dump_addr + (i * VIEW_MEMORY_DUMP_RANGE)
            s = '{:08X}'.format(x)
            self.canvas.create_text(0, self.font_char_height * i, font=self.font, tags=self.address_line_tag + s,
                                    text=s,
                                    activefill='#33FF33',
                                    fill=TEXT_COLOR, anchor="nw")

    def _draw_dword_separate_line(self):
        self.draw_data_base_x = self.addr_rect_pix_width + (self.font_char_width * 1)
        self.dword_block_width = 4 * (self.font_char_width * 3)
        self.dword_block_width = self.dword_block_width + self.font_char_width  # space after before end line | e.g. FF |

        for i in range(5):
            x = self.draw_data_base_x + (self.dword_block_width * i)
            if x > self.width:
                break
            self.canvas.create_line(x, 0, x, self.height, fill=TEXT_COLOR)

    def get_raw_byte_data_from_memory_buffer(self, i, dump_buffer):
        rr = ""
        if i < len(dump_buffer):
            rr = ord(dump_buffer[i:i + 1])
            return True, rr

        return False, 0x0

    def get_formated_byte_data_from_memory_buffer(self, i, dump_buffer):
        c = ""
        if i < len(dump_buffer):
            c = binascii.hexlify(dump_buffer[i])
        else:
            c = "??"
        return c

    def hex_byte_addr_to_hex_tag(self, addr):
        name_tag = '{:08X}'.format(addr)
        name_tag = self.hex_tag_prefix + name_tag
        return name_tag

    def hex_byte_addr_to_ascii_tag(self, addr):
        ascii_tag = 'ascii_tag_{:08X}'.format(addr)
        return ascii_tag

    def hex_value_to_printable_ascii_chr(self, v):
        s = ""
        if 0x20 < v < 0x7F:
            s += chr(v)
        else:
            s += "."
        return s

    def _draw_memory_data(self, dump_addr, dump_buffer):

        data_draw_area = self.width - self.draw_data_base_x
        if data_draw_area < (self.font_char_width * 3):
            return

        data_size = self.number_of_line * (self.font_char_width * 3)
        progress = (self.font_char_width * 3)

        nr_element_in_line = 4

        hex_id = 0
        ascii_id = 0
        text_x = 0
        base_y = 0
        for i in range(self.number_of_line):
            base_y = i * self.font_char_height

            for j in range(nr_element_in_line):
                text_x = (self.draw_data_base_x + self.font_char_width) + (j * self.dword_block_width)
                for k in range(4):
                    dump_byte = self.get_formated_byte_data_from_memory_buffer(
                        (i * VIEW_MEMORY_DUMP_RANGE) + (j * 4) + k, dump_buffer)
                    hex_tag = self.hex_byte_addr_to_hex_tag(dump_addr + hex_id)

                    item = self.canvas.create_text(text_x, base_y, font=self.font, tags=hex_tag, text=dump_byte,
                                                   activefill='#33FF33',
                                                   fill=TEXT_COLOR, anchor="nw")

                    hex_id += 1
                    text_x += (self.font_char_width * 3)

            text_x += (self.font_char_width * 1)
            for l in range(4 * 4):
                tag_name = self.hex_byte_addr_to_ascii_tag(dump_addr + ascii_id)

                (read_success, raw_byte) = self.get_raw_byte_data_from_memory_buffer(ascii_id, dump_buffer)
                if read_success:
                    show_char = self.hex_value_to_printable_ascii_chr(raw_byte)
                else:
                    show_char = "??"

                item = self.canvas.create_text(text_x, base_y, font=self.font, tags=tag_name, text=show_char,
                                               activefill='#33FF33', fill=TEXT_COLOR, anchor="nw")
                text_x += (self.font_char_width * 1)
                ascii_id += 1

    def _draw_cursor_caret(self):
        pass

    def _draw_text_data_on_canvas(self, dump_addr, dump_buffer):
        self.canvas.delete("all")
        self.draw_addr_area(dump_addr)
        self._draw_dword_separate_line()
        self._draw_memory_data(dump_addr, dump_buffer)
        # self._draw_cursor_caret()

        (w, h) = (self.font.measure("W"), self.font.metrics("linespace"))

    def click(self, event):
        self.focus_set()
        self.mouse_x, self.mouse_y = event.x, event.y
        self.set_current_as_main_view_frame()

        canv_click_id = self.canvas.find_withtag(tk.CURRENT)
        tags = self.canvas.gettags(canv_click_id)
        self.mouse_click_tags = tags

        if len(tags) > 1:
            caret_tag_id = self.canvas.find_withtag(self.caret_rect_tag)
            if len(caret_tag_id) > 0:
                self.canvas.delete(caret_tag_id)

            r = self.canvas.create_rectangle(self.canvas.bbox(tags[0]), fill="#193300", tags='caret_rect_tag')
            self.canvas.tag_lower(r)

        return

    def set_current_as_main_view_frame(self):
        global g_current_memory_view_frame_number
        g_current_memory_view_frame_number = self.view_frame_number

    def on_resize(self, event):
        self.width = event.width
        self.height = event.height
        self.number_of_line = self.height // self.font_char_height
        # resize the canvas
        self.config(width=self.width, height=self.height)

        # do it only for the first frame the second is the same
        self.emulator_core.set_mem_view_range(self.number_of_line * VIEW_MEMORY_DUMP_RANGE, self.view_frame_number)

        if self.emulator_core.is_wait_for_user_input():
            if self.view_frame_number == 0:
                self.emulator_core.update_buffer_view_memory1()
                view1_addr, view1_buffer = self.emulator_core.get_mem_view1_addr_data()
                self.display_memory_from_browsing(view1_addr, view1_buffer)
            elif self.view_frame_number == 1:
                self.emulator_core.update_buffer_view_memory2()
                view2_addr, view2_buffer = self.emulator_core.get_mem_view2_addr_data()
                self.display_memory_from_browsing(view2_addr, view2_buffer)

    def get_dump_memory_data_range(self):
        return self.number_of_line * (self.font_char_width * 3) * 16

    def update_hex_tag_value(self, dump_addr, buffer):

        for i in range(len(buffer)):
            hex_tag = self.hex_byte_addr_to_hex_tag(dump_addr + i)
            item = self.canvas.find_withtag(hex_tag)

            if len(item) == 0:
                assert False
                return
            assert (len(item) == 1)
            item = item[0]
            hex_color = TEXT_COLOR
            item_text = binascii.hexlify(buffer[i])
            self.canvas.itemconfig(item, tags=hex_tag, fill=hex_color, text=item_text)

    def update_ascii_tag_value(self, dump_addr, buffer):

        for i in range(len(buffer)):
            ascii_char_tag = self.hex_byte_addr_to_ascii_tag(dump_addr + i)
            item = self.canvas.find_withtag(ascii_char_tag)

            if len(item) == 0:
                assert (False)
                return
            assert (len(item) == 1)
            item = item[0]

            (read_success, raw_byte) = self.get_raw_byte_data_from_memory_buffer(i, buffer)
            show_char = self.hex_value_to_printable_ascii_chr(raw_byte)

            hex_color = TEXT_COLOR
            self.canvas.itemconfig(item, tags=ascii_char_tag, activefill='#33FF33', fill=TEXT_COLOR, text=show_char)

    def get_changed_byte_addr_list(self, dump_addr, buffer, prev_dump_addr, prev_dump_buffer):
        assert (dump_addr == prev_dump_addr)
        assert (len(buffer) == len(prev_dump_buffer))

        addr_list = []
        for i in range(len(buffer)):
            hex_tag = self.hex_byte_addr_to_hex_tag(dump_addr + i)
            item = self.canvas.find_withtag(hex_tag)

            if len(item) == 0:
                assert (False)
                return
            assert (len(item) == 1)
            item = item[0]
            if buffer[i] != prev_dump_buffer[i]:
                addr_list.append(dump_addr + i)
        return addr_list

    def mark_changed_bytes(self, addr_list):

        for i in range(len(addr_list)):
            addr = addr_list[i]
            hex_tag = self.hex_byte_addr_to_hex_tag(addr)
            item = self.canvas.find_withtag(hex_tag)
            if len(item) == 0:
                continue
            assert (len(item) == 1)
            item = item[0]
            hex_color = "#00ffff"
            self.canvas.itemconfig(item, tags=hex_tag, fill=hex_color)

        return

    def display_memory_from_browsing(self, dump_addr, dump_buffer):

        # everything the same do nothing
        if dump_addr == self.current_dump_addr and \
                        len(dump_buffer) == len(self.current_dump_buffer) and dump_buffer == self.current_dump_buffer:
            if not self.highlight_byte_addr_list:
                return

        # buffer change need to update tag values
        if dump_addr == self.current_dump_addr and \
                        len(dump_buffer) == len(self.current_dump_buffer) and \
                        dump_buffer != self.current_dump_buffer:
            self.update_hex_tag_value(dump_addr, dump_buffer)
            self.update_ascii_tag_value(dump_addr, dump_buffer)

        else:
            self._draw_text_data_on_canvas(dump_addr, dump_buffer)
            self.current_dump_addr = dump_addr
            self.current_dump_buffer = dump_buffer

            self.mark_changed_bytes(self.highlight_byte_addr_list)

    def display_memory_from_single_step(self, addr, buf):
        """
        Display new memory data and snapshot it to compare with the next single step data
        """

        # pdb.set_trace()
        dump_addr = addr
        dump_buffer = buf

        # everything the same do nothing
        if dump_addr == self.current_dump_addr and \
                        len(dump_buffer) == len(self.current_dump_buffer) and dump_buffer == self.current_dump_buffer:
            if not self.highlight_byte_addr_list:
                return

        self.highlight_byte_addr_list = []  # reset list

        # buffer change need to update tag values
        if dump_addr == self.current_dump_addr and \
                        len(dump_buffer) == len(self.current_dump_buffer) and \
                        dump_buffer != self.current_dump_buffer:

            self.update_hex_tag_value(dump_addr, dump_buffer)
            self.update_ascii_tag_value(dump_addr, dump_buffer)

            changed_bytes_list = self.get_changed_byte_addr_list(dump_addr, dump_buffer, self.current_dump_addr,
                                                                 self.current_dump_buffer)
            self.mark_changed_bytes(changed_bytes_list)

            self.current_dump_addr = dump_addr
            self.current_dump_buffer = dump_buffer
            self.highlight_byte_addr_list = changed_bytes_list
        else:
            self._draw_text_data_on_canvas(dump_addr, dump_buffer)

            self.current_dump_addr = dump_addr
            self.current_dump_buffer = dump_buffer

    def clear_mem_view(self):
        self.current_dump_buffer = ""
        self.current_dump_addr = IMAGEBASE
        self.canvas.delete("all")


#
# Disassembly window
#
class DisassemblyWindow(tk.Frame):
    def __init__(self, master=None):
        self.parent = master
        tk.Frame.__init__(self, self.parent, bg='bisque', borderwidth=1, relief="sunken")
        self._create_layout()
        self._create_settings()
        self._create_bindings()

    def _create_settings(self):
        self.emulator_core = None
        self.disasm_number_of_lines = 0
        self.disasm_edit_area.tag_configure("ip_ln_highlight_tag", foreground="#e9e9e9", background="#808080")
        self.disasm_edit_area.tag_configure("bp_active_ln_highlight_tag", foreground="#FFFFFF", background="#CC0000")
        self.disasm_edit_area.tag_configure("cpu_registers_tag", foreground="#DAA520", background=BACKGROUND_COLOR)
        self.disasm_edit_area.tag_configure("branch_instr_tag", foreground="#FFCC00", background=BACKGROUND_COLOR)
        self.disasm_edit_area.tag_configure("word_under_cur_tag", foreground=BACKGROUND_COLOR, background="#FFFF00")
        self.word_under_cursor = ""
        self.prev_cursor_position_str = ""

    def _create_layout(self):
        self.font = tkFont.Font(family=FONT_FAMILY, size=FONT_SIZE)
        (self.font_width, self.font_height) = (self.font.measure("W"), self.font.metrics("linespace"))

        self.disasm_edit_area = tk.Text(self, wrap=tk.NONE, undo=True,
                                        width=1, height=1,
                                        relief=tk.SUNKEN, borderwidth=5,
                                        highlightthickness=0, insertbackground="white")
        self.disasm_edit_area.config(font=self.font)
        self.disasm_edit_area.configure(bg="black", fg=TEXT_COLOR)

        self.scrollbarY = tk.Scrollbar(self, orient=tk.VERTICAL)
        self.scrollbarX = tk.Scrollbar(self, orient=tk.HORIZONTAL)

        self.status_label_text = tk.StringVar()
        self.status_label_text.set("")

        self.status = tk.Label(self, text="", textvariable=self.status_label_text, bd=1, relief=tk.SUNKEN,
                               anchor=tk.W, bg='lightgray')

        self.disasm_edit_area.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.scrollbarY.grid(row=0, column=1, sticky=(tk.N, tk.S), rowspan=2)
        self.scrollbarX.grid(row=1, column=0, sticky=(tk.W, tk.E))
        self.status.grid(row=2, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), columnspan=2)

        self.rowconfigure(0, weight=1)
        self.columnconfigure(0, weight=1)

        self.disasm_edit_area.configure(yscrollcommand=self.scrollbarY.set, xscrollcommand=self.scrollbarX.set)

        self.scrollbarY.config(command=self.disasm_edit_area.yview)
        self.scrollbarX.config(command=self.disasm_edit_area.xview)

    def add_emulator_core_access(self, emul_uc):
        self.emulator_core = emul_uc

    def _create_bindings(self):
        self.disasm_edit_area.bind("<Configure>", self.on_dasm_view_resize)
        self.disasm_edit_area.bind('<Double-1>', self.mouse_double_click)
        self.disasm_edit_area.bind('<Key-F2>', self.on_toggle_line_breakpoint_key_pressed)

        os = platform.system()
        if os == "Linux":
            self.disasm_edit_area.bind('<4>', self.on_mousewheel_scroll_up)
            self.disasm_edit_area.bind('<5>', self.on_mousewheel_scroll_down)
        else:
            # Windows and MacOS
            self.disasm_edit_area.bind("<MouseWheel>", self.on_mousewheel)

    def on_mousewheel_scroll_up(self, event=None):
        if not self.emulator_core.is_wait_for_user_input():
            return
        curr_addr = prev_addr = self.emulator_core.get_dasm_listing_first_addr()
        if None == prev_addr:
            return
        prev_addr -= (4 * 3)
        if not self.emulator_core.is_mem_region_mapped(prev_addr):
            prev_addr = self.emulator_core.find_prev_mem_begin_region(curr_addr)
            if prev_addr == None:
                return
        self.emulator_core.reload_dasm_listing_with_unassemble_from_addr(prev_addr)
        self.emulator_core.set_dasm_view_update()

    def on_mousewheel_scroll_down(self, event=None):
        if not self.emulator_core.is_wait_for_user_input():
            return
        next_addr = self.emulator_core.get_dasm_listing_first_addr()
        if None == next_addr:
            return
        next_addr += (4 * 3)
        if not self.emulator_core.is_mem_region_mapped(next_addr):
            return
        self.emulator_core.reload_dasm_listing_with_unassemble_from_addr(next_addr)
        self.emulator_core.set_dasm_view_update()

    def on_mousewheel(self, event=None):
        delta = (event.delta / 120)
        if delta > 0:
            self.on_mousewheel_scroll_up()
        else:
            self.on_mousewheel_scroll_down()

    def on_toggle_line_breakpoint_key_pressed(self, event=None):
        pos_str = self.disasm_edit_area.index("insert linestart")
        # print (pos_str)
        dot_offset = pos_str.find('.')
        index = 0
        if dot_offset == -1:
            return
        try:
            index = int(pos_str[0:dot_offset], 10)
        except ValueError:
            pass

        index = index - 1  # addr index starts from 0
        if self.emulator_core.is_wait_for_user_input():
            (ok, addr) = self.emulator_core.dasm_listing_index_to_addr(index)
            if ok:
                (bp_found, state) = self.emulator_core.get_bp_settings_for_addr(addr)
                if bp_found:
                    self.emulator_core.del_bp_addr(addr)
                else:
                    self.emulator_core.toggle_bp_settings(addr, 1)
                self.prev_cursor_position_str = pos_str
                self.emulator_core.set_dasm_view_update()

    def highlight_word_under_cursor(self):

        self.disasm_edit_area.tag_remove("word_under_cur_tag", "1.0", tk.END)

        if self.disasm_edit_area.tag_ranges("sel"):
            try:
                tmp_under_cur_text = self.disasm_edit_area.get(tk.SEL_FIRST, tk.SEL_LAST)
                tmp_under_cur_text = tmp_under_cur_text.strip()
                if tmp_under_cur_text.startswith(", "):
                    self.word_under_cursor = ""
                    return
                elif len(tmp_under_cur_text):
                    self.highlight_keyword(tmp_under_cur_text, "word_under_cur_tag")

                    #
                    # pad a string len 8 e.g. 0x1000 to 00001000 and highlight address (if found in the dasm listing)
                    #
                    if tmp_under_cur_text.startswith("0x"):
                        try:
                            imm = int(tmp_under_cur_text, 16)
                            addr_str = '{:08X}'.format(imm)
                            self.highlight_keyword(addr_str, "word_under_cur_tag")
                        except ValueError:
                            pass
                    elif tmp_under_cur_text.startswith("#0x"):
                        try:
                            imm = int(tmp_under_cur_text[1:], 16)
                            addr_str = '{:08X}'.format(imm)
                            self.highlight_keyword(addr_str, "word_under_cur_tag")
                        except ValueError:
                            pass

                    self.word_under_cursor = tmp_under_cur_text
            except tk.TclError:
                self.word_under_cursor = ""
                pass

    def mouse_double_click(self, event):
        self.after(100, self.highlight_word_under_cursor)

    def on_dasm_view_resize(self, event):
        self.disasm_number_of_lines = event.height // self.font_height
        if self.disasm_number_of_lines > 0:
            self.disasm_number_of_lines -= 1
        else:
            self.disasm_number_of_lines = 1
            return

        if event.height <= self.font_height * 4:
            return

        if not self.emulator_core.is_dasm_view_update():
            self.emulator_core.set_disasm_number_of_lines(self.disasm_number_of_lines)

        if self.emulator_core.is_wait_for_user_input() and self.emulator_core.is_dasm_view_update() == False:
            self.emulator_core.set_dasm_view_update()

    def set_status_label_text(self, txt):
        self.status_label_text.set(txt)

    def highlight_keyword(self, keyword, tag):
        if len(keyword) == 0:
            return
        pos = '1.0'
        while True:
            idx = self.disasm_edit_area.search(keyword, pos, tk.END)
            if not idx:
                break
            pos = '{}+{}c'.format(idx, len(keyword))
            self.disasm_edit_area.tag_add(tag, idx, pos)

    def clear_dasm_view_edit_area(self):
        self.disasm_edit_area.delete('1.0', tk.END)

    def update_dasm_view_edit_area(self, dasm_listing_dict, ip_highlight_ln):
        if not dasm_listing_dict:
            return

        bo_settings = self.emulator_core.get_bp_settings()
        self.disasm_edit_area.delete('1.0', tk.END)
        bp_highlight_ln = []

        curr_text_line = 1
        for key_addr in dasm_listing_dict:

            if curr_text_line > 1:
                self.disasm_edit_area.insert(tk.END, "\n")

            if key_addr in bo_settings:
                if ip_highlight_ln != curr_text_line:
                    bp_highlight_ln.append(curr_text_line)

            dasm_text_line = dasm_listing_dict[key_addr]
            self.disasm_edit_area.insert(tk.END, dasm_text_line)
            curr_text_line += 1

        self.highlight_keyword("r0", "cpu_registers_tag")
        self.highlight_keyword("r1", "cpu_registers_tag")
        self.highlight_keyword("r2", "cpu_registers_tag")
        self.highlight_keyword("r3", "cpu_registers_tag")
        self.highlight_keyword("r4", "cpu_registers_tag")
        self.highlight_keyword("r5", "cpu_registers_tag")
        self.highlight_keyword("r6", "cpu_registers_tag")
        self.highlight_keyword("r7", "cpu_registers_tag")
        self.highlight_keyword("r8", "cpu_registers_tag")
        self.highlight_keyword("r9", "cpu_registers_tag")
        self.highlight_keyword("r10", "cpu_registers_tag")
        self.highlight_keyword("r11", "cpu_registers_tag")
        self.highlight_keyword("r12", "cpu_registers_tag")
        self.highlight_keyword("r13", "cpu_registers_tag")
        self.highlight_keyword("r14", "cpu_registers_tag")
        self.highlight_keyword("pc", "cpu_registers_tag")

        self.highlight_keyword(" bne ", "branch_instr_tag")
        self.highlight_keyword(" bl ", "branch_instr_tag")
        self.highlight_keyword(" b ", "branch_instr_tag")
        self.highlight_keyword(" bls ", "branch_instr_tag")
        self.highlight_keyword(" beq ", "branch_instr_tag")
        self.highlight_keyword(" bxeq ", "branch_instr_tag")

        self.disasm_edit_area.tag_lower('cpu_registers_tag')
        self.disasm_edit_area.tag_lower('branch_instr_tag')

        if ip_highlight_ln != -1 and ip_highlight_ln <= (self.disasm_number_of_lines):
            # highlight IP/PC line
            begin = str(ip_highlight_ln) + ".0"
            end = str(ip_highlight_ln) + ".end+1c"
            self.disasm_edit_area.tag_add("ip_ln_highlight_tag", begin, end)

        for i in range(len(bp_highlight_ln)):
            ln = bp_highlight_ln[i]
            begin = str(ln) + ".0"
            end = str(ln) + ".end+1c"
            self.disasm_edit_area.tag_add("bp_active_ln_highlight_tag", begin, end)

        if len(self.prev_cursor_position_str) != 0:
            self.disasm_edit_area.mark_set("insert", self.prev_cursor_position_str)
            self.prev_cursor_position_str = ""

    def go_continue_run(self):
        if self.emulator_core.is_emulator_running() and self.emulator_core.is_wait_for_user_input():
            self.disasm_edit_area.tag_remove("ip_ln_highlight_tag", "1.0", 'end')
            self.emulator_core.gogo_emulator()


#
# MainWindow
#
class MainWindow(tk.Frame):
    def __init__(self, master=None):
        self.parent = master
        self.load_file_name = ""
        tk.Frame.__init__(self, self.parent, bg='bisque', borderwidth=1, relief="sunken")
        self._create_objects()
        self._create_layout()
        self._create_menu()
        self._create_coupling()
        self._create_settings()
        self._create_bindings()
        self._on_time_shot()

    def _create_bindings(self):
        self.bind("<Configure>", self.main_frame_resize_event)

    def main_frame_resize_event(self, event):
        w, h = event.width, event.height
        if self.emulator_core.is_emulator_running():
            print ("resize windows")

    def _create_settings(self):
        self.mem_view_frame1.set_view_number(0)
        self.mem_view_frame2.set_view_number(1)

    def _create_coupling(self):
        self.dasm_frame.add_emulator_core_access(self.emulator_core)
        self.command_line_frame.add_emulator_core_access(self.emulator_core)
        self.mem_view_frame1.add_emulator_core_access(self.emulator_core)
        self.mem_view_frame2.add_emulator_core_access(self.emulator_core)

    def _create_objects(self):
        self.emulator_core = EmulatorCore()

    def _create_layout(self):
        self.dasm_frame = DisassemblyWindow(self)
        self.register_frame = RegisterWindow(self)
        self.mem_view_frame1 = MemoryViewWindow(self)
        self.mem_view_frame2 = MemoryViewWindow(self)
        self.command_line_frame = CommandLineWindow(self)

        self.dasm_frame.grid(row=0, column=0, rowspan=1, columnspan=8, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.register_frame.grid(row=0, column=8, rowspan=1, columnspan=2, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.mem_view_frame1.grid(row=1, column=0, rowspan=1, columnspan=5, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.mem_view_frame2.grid(row=1, column=5, rowspan=1, columnspan=5, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.command_line_frame.grid(row=2, column=0, rowspan=1, columnspan=10, sticky=(tk.N, tk.S, tk.W, tk.E))

        self.rowconfigure(0, weight=4)
        self.rowconfigure(1, weight=2)
        self.rowconfigure(2, weight=1)

        for c in range(10):
            self.columnconfigure(c, weight=1)

    def close_quit(self, event=None):
        global program_exit
        program_exit = True

        self.parent.destroy()

    def _create_menu(self):
        self.menubar = tk.Menu(self.parent)

        self.filemenu = tk.Menu(self.menubar, tearoff=0)
        self.filemenu.add_command(label="Open", command=self.open_file)
        self.filemenu.add_separator()
        self.filemenu.add_command(label="Start input server", command=self.start_input_server)
        self.filemenu.add_command(label="Save memory dump as...", command=self.save_binary_dump)
        self.filemenu.add_separator()

        self.filemenu.add_command(label="Exit", command=self.close_quit)
        self.menubar.add_cascade(label="File", menu=self.filemenu)

        self.emulmenu = tk.Menu(self.menubar, tearoff=0)
        self.emulmenu.add_command(label="Single step", accelerator="F7", command=self.on_single_step_from_menu)
        self.emulmenu.add_command(label="Go", accelerator="F5", command=self.on_emul_gogo)
        self.emulmenu.add_command(label="Break", command=self.break_emul_execution)
        self.emulmenu.add_command(label="Stop emulator", command=self.on_emul_stop)
        self.emulmenu.add_command(label="Toggle breakpoint", accelerator="F2", command=self.toggle_breakpoint_from_menu)
        self.emulmenu.add_command(label="Restart", command=self.restart_file_load)
        self.menubar.add_cascade(label="Emulator", menu=self.emulmenu)

        self.helpmenu = tk.Menu(self.menubar, tearoff=0)
        self.helpmenu.add_command(label="About...", command=self.dummy_func)
        self.menubar.add_cascade(label="Help", menu=self.helpmenu)

        self.parent.bind('<Key-F7>', self.on_single_step)
        self.parent.bind('<Key-F1>', self.on_focus_cmd_line)
        self.parent.bind('<Key-F5>', self.on_emul_gogo)

        self.parent.config(menu=self.menubar)

    def dummy_func(self):
        self.emulator_core.write_test_data()
        print("dummy")
        pass

    def update_all_memory_windows_browsing_dump_data(self):

        self.emulator_core.update_buffer_view_memory1()
        self.emulator_core.update_buffer_view_memory2()

        view1_addr, view1_buffer = self.emulator_core.get_mem_view1_addr_data()
        view2_addr, view2_buffer = self.emulator_core.get_mem_view2_addr_data()

        self.mem_view_frame1.display_memory_from_browsing(view1_addr, view1_buffer)
        self.mem_view_frame2.display_memory_from_browsing(view2_addr, view2_buffer)

    def update_all_memory_windows_single_step_dump_data(self):
        view1_addr, view1_buffer = self.emulator_core.get_mem_view1_addr_data()
        view2_addr, view2_buffer = self.emulator_core.get_mem_view2_addr_data()

        self.mem_view_frame1.display_memory_from_single_step(view1_addr, view1_buffer)
        self.mem_view_frame2.display_memory_from_single_step(view2_addr, view2_buffer)

    def set_load_file_name(self, fname):
        self.load_file_name = fname

    def load_input_stream_wrapper(self, binary_stream):
        print("[!] load_input_stream_wrapper")
        self.after(5000, self.load_input_stream(binary_stream))

    def load_input_stream(self, binary_stream):
        global ENTRYPOINT
        global IMAGEBASE
        global IS_THUMB_MODE

        if len(binary_stream) == 0:
            return
        self.emulator_core.reset_run_counter()

        ENTRYPOINT = 0
        IMAGEBASE = 0

        print("[i] Loading code from stream client")
        print("Imagebase: 0x" + '{:08X}'.format(IMAGEBASE) + " Entrypoint: 0x" + '{:08X}'.format(ENTRYPOINT))

        binary_stream_size = self.emulator_core.load_binary_stream(binary_stream)
        if binary_stream_size != 0:
            print("Loaded binary stream: size: 0x{:04x}".format(binary_stream_size))
            self.parent.title("Stream from client")
            self.emulator_core.start_emul_thread()

            self.dasm_frame.set_status_label_text("")
            self.after(10, self.emul_even_worker_loop)

    def load_input_file(self):
        if self.load_file_name == "":
            return

        self.emulator_core.reset_run_counter()
        file_size = self.emulator_core.load_input_file(self.load_file_name)
        if file_size != 0:
            print("Loaded file: {:s} - file size: 0x{:04x}".format(self.load_file_name, file_size))
            self.parent.title(self.load_file_name)
            self.emulator_core.start_emul_thread()

            self.dasm_frame.set_status_label_text("")
            self.after(10, self.emul_even_worker_loop)

        else:
            print("Load file error %s" % self.load_file_name)

    #
    # Emul thread event loop
    #
    def emul_even_worker_loop(self):
        global program_exit

        if program_exit == True or self.emulator_core.is_emulator_running() == False:
            self.after(100, self.emul_even_worker_finished())
            return

        if self.emulator_core.is_emul_data_waiting():
            self.update_all_frames_with_new_emul_data()

        elif self.emulator_core.is_wait_for_user_input() and self.emulator_core.is_dasm_view_update():
            self.update_dasm_view_window()

        elif self.emulator_core.is_wait_for_user_input() and self.emulator_core.is_register_view_update():
            self.update_register_view_window()

        elif self.emulator_core.is_wait_for_user_input() and self.emulator_core.is_update_mem_view():
            self.update_mem_frames_with_new_emul_data()

        self.after(10, self.emul_even_worker_loop)
        return

    def emul_even_worker_finished(self):
        last_error = self.emulator_core.get_last_error()
        self.dasm_frame.set_status_label_text(last_error)
        self.dasm_frame.clear_dasm_view_edit_area()
        self.mem_view_frame1.clear_mem_view()
        self.mem_view_frame2.clear_mem_view()
        self.update_register_view_window_with_last_reg_data()

        print ("Emulator thread finished: %s" % (time.ctime(time.time())))

    def update_register_view_window_with_last_reg_data(self):
        last_reg_data = self.emulator_core.get_register_last_data()
        self.register_frame.update_register_view(last_reg_data)

        self.command_line_frame.print_emul_exit_context(last_reg_data)

    def update_register_view_window(self):
        reg_data = self.emulator_core.get_register_data()
        self.register_frame.update_register_view(reg_data)
        self.emulator_core.reset_update_register_view()
        pass

    def update_dasm_view_window(self):
        if self.emulator_core.reload_dasm_listing():
            dasm_lines = self.emulator_core.get_disasm_listing_dict()
            if dasm_lines:
                highlight_ln = self.emulator_core.get_highlight_line_num()
                self.dasm_frame.update_dasm_view_edit_area(dasm_lines, highlight_ln)
        self.emulator_core.reset_dasm_view_update()

    def update_mem_frames_with_new_emul_data(self):
        self.update_all_memory_windows_browsing_dump_data()
        self.emulator_core.reset_update_mem_view()

    def update_all_frames_with_new_emul_data(self):
        dasm_listing_dict = self.emulator_core.get_disasm_listing_dict()
        highlight_ln = self.emulator_core.get_highlight_line_num()
        reg_data = self.emulator_core.get_register_data()

        # pdb.set_trace()

        self.dasm_frame.update_dasm_view_edit_area(dasm_listing_dict, highlight_ln)
        self.register_frame.update_register_view(reg_data)
        self.update_all_memory_windows_single_step_dump_data()

        assert (self.emulator_core.is_emul_data_waiting() == True)
        self.emulator_core.reset_emul_data_waiting()

    def _on_time_shot(self):
        self.after(100, self.load_input_file)

    def get_filename_from_user(self):
        filename = ""
        if sys.version_info[0] < 3:
            filename = askopenfilename(title="Open file", filetypes=[])
        else:
            filename = filedialog.askopenfilename(title="Open file", filetypes=[])
        return filename

    def start_input_server(self):
        if self.emulator_core.is_emulator_running():
            print("[!] Emulator running")
            return

        # FIXME: this is a bit buggy since it will block UI
        self.after(100, self.spawn_byte_stream_server_worker())

    def spawn_byte_stream_server_worker(self):
        print("[i] Starting stream server")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        host = socket.gethostname()
        port = 5559

        s.bind((host, port))
        s.listen(1)
        conn, addr = s.accept()
        bin_stream = b""
        print('Connected by', addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            bin_stream += data

        conn.close()
        self.after(100, self.load_input_stream(bin_stream))

    def open_file(self):
        if self.emulator_core.is_emulator_running():
            print("[!] Emulator running")
            return

        filename = TEST_FILENAME
        if len(filename) == 0:
            filename = self.get_filename_from_user()
            if len(filename):
                self.preload_input_file_start_emul(filename)
        else:
            self.preload_input_file_start_emul(filename)

    def preload_input_file_start_emul(self, filename):
        self.set_load_file_name(filename)
        self.after(100, self.load_input_file)

    def restart_file_load(self):
        if self.emulator_core.is_emulator_running():
            print("[!] Emulator running")
            return
        if len(self.load_file_name):
            self.after(100, self.load_input_file)

    def save_binary_dump(self):
        pass

    def on_single_step_from_menu(self):
        self.on_single_step(self)

    def on_emul_stop(self):
        self.emulator_core.stop_emulator()

    def on_emul_gogo(self, event=None):
        self.dasm_frame.go_continue_run()

    def break_emul_execution(self):
        self.emulator_core.set_break_run()

    def toggle_breakpoint_from_menu(self):
        self.dasm_frame.on_toggle_line_breakpoint_key_pressed()

    # @staticmethod
    def on_single_step(self, event):
        self.emulator_core.single_step_emulator()

    def on_focus_cmd_line(self, event):
        self.command_line_frame.on_focus_cmd_line()

    def is_emul_running(self):
        return self.emulator_core.is_emulator_running()


def maximize_window(root):
    w, h = root.winfo_screenwidth(), root.winfo_screenheight()
    root.geometry("%dx%d+0+0" % (w, h))


#
#   MAIN
#
def main():
    load_file_name = ""
    if len(sys.argv) > 1:
        load_file_name = str(sys.argv[1])

    root = tk.Tk()

    root.title("JuniEmul")
    root.geometry("850x500+525+300")
    # maximize_window(root)

    try:
        path = os.path.join(os.path.dirname(__file__), "images/")
        print (path)
        if sys.platform.startswith("win"):
            icon = path + "interest.ico"
        else:
            icon = "@" + path + "interest.xbm"
            # application.iconbitmap(icon)
    except:
        pass

    root.configure(background="#808080")
    root.option_add("*font", ("Courier New", 9, "normal"))

    window = MainWindow(master=root)
    window.pack(side="top", fill="both", expand=True)

    root.protocol("WM_DELETE_WINDOW", window.close_quit)
    root.mainloop()

    if window.is_emul_running():
        print("Emulator force exit")
        os._exit(-1)


if __name__ == '__main__':
    main()
    
